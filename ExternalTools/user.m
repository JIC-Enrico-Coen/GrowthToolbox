function [ r, seed ] = user ( dim_num, n, seed, varargin )

%% USER samples points in a user-specified region with given density.
%
%  Discussion:
%
%    This routine can be used to 
%
%    * specify an interesting initial configuration for the data,
%      by specifing that USER be used for initialization (INIT = 3);
%
%    * specify the shape of the computational region, by specifying
%      that sample points are to be generated by this routine, 
%      (SAMPLE = 3) and then returning sample points uniformly at random.
%
%    * specify the distribution or density function, by specifying
%      that sample points are to be generated by this routine, 
%      (SAMPLE = 3 ) and then returning sample points according to a 
%      given probability density function.
%
%  Author:
%
%    John Burkardt
%
%  Modified:
%
%    23 June 2005
%
%  Parameters:
%
%    Input, integer DIM_NUM, the spatial dimension.
%
%    Input, integer N, the number of sample points desired.
%
%    Input, integer SEED, a seed for the random number generator.
%
%    Input, string USERTYPE, specifying what sort of user data are supplied.
%
%    Input, struct USERDATA, user data.
%
%    Output, real R(DIM_NUM,N), a set of N sample values.
%
%    Output, integer SEED, the updated seed.  
%

    if isempty( varargin )
        error( 'No usertype.' );
        % This does not return.
    end
        
    if isstruct( varargin{1} )
        userparams = varargin{1};
    else
        userparams = cvt_convert_oldstyle_userargs( varargin{:} );
        if isempty( userparams )
            % Assumed to be new-style name-value pairs.
            userparams = safemakestruct( mfilename(), varargin{:} );
        end
    end
    
    if ~isfield( userparams, 'usertype' )
        error( 'No usertype.' );
        % This does not return.
    end
    
    switch userparams.usertype
        case 'rectangle'
            r = randInRectangle( n, userparams.bbox )';
        case 'testrectangle'
            r = randInRectangle( n, userparams.bbox )';
            bbox = varargin{1};
            xlo = bbox(1);
            xhi = bbox(2);
            xs = r(1,:);
            xs = (xs-xlo)/2 + xlo;
            r(1,:) = xs;
        case 'semiellipse'
            r = randInSemiEllipse( n, userparams.bbox, userparams.axis )';
        case 'ellipse'
            r = randInEllipse( n, userparams.bbox )';
        case 'polygon'
            r = randInPoly( n, userparams.poly )';
        case { '', 'unitcircle' }
            r = randInCircle( n, 1 );
        case { 'spheresurf' }
            r = randOnSphere( n )';
        case 'meshcells'
            % Following arguments are the mesh and an array of cells.
%             mesh = varargin{1};
%             cellIndexes = varargin{2};
            r = randInFEMcells( userparams.mesh, userparams.elements, n )';
        %    cellAreas = mesh.cellareas( cellIndexes );
        %    [cells,bcs] = randInTriangles( cellAreas, n );
        %    r = meshBaryToGlobalCoords( mesh, cellIndexes(cells), bcs )';
        case 'triangles'
            % Following arguments represent a list of triangles.
            % varargin{1} is a list of node coordinates.
            % varargin{2} is a list of triples of node indexes.
            % varargin{3} is a list of areas of the triangles.
            % varargin{4} is a list of indexes into varargin{2}.
            % WARNING: THIS IS NOT COMPATIBLE WITH THE CURRENT DEFINITION
            % OF randInTriangles().
            r = randInTriangles( n, userparams.vxs, userparams.trivxs, userparams.triareas, userparams.whichtris );
        otherwise
            error( 'Unknown usertype %d', userparams.usertype );
            % This does not return.
    end
    
    if size(r,2) > dim_num
        r = r(1:dim_num,:);
    elseif size(r,2) < dim_num
        r(end,dim_num) = 0; % This fills all the missing columns with zeros.
        % r = [ r zeros( n, dim_num-2 ) ];
    end
end



